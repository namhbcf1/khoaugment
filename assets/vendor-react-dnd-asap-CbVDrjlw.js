const t="undefined"!=typeof global?global:self,e=t.MutationObserver||t.WebKitMutationObserver;function s(t){return function(){const e=setTimeout(n,0),s=setInterval(n,50);function n(){clearTimeout(e),clearInterval(s),t()}}}const n="function"==typeof e?function(t){let s=1;const n=new e(t),i=document.createTextNode("");return n.observe(i,{characterData:!0}),function(){s=-s,i.data=s}}:s;class i{call(){try{this.task&&this.task()}catch(t){this.onError(t)}finally{this.task=null,this.release(this)}}constructor(t,e){this.onError=t,this.release=e,this.task=null}}const r=new class{enqueueTask(t){const{queue:e,requestFlush:s}=this;e.length||(s(),this.flushing=!0),e[e.length]=t}constructor(){this.queue=[],this.pendingErrors=[],this.flushing=!1,this.index=0,this.capacity=1024,this.flush=()=>{const{queue:t}=this;for(;this.index<t.length;){const e=this.index;if(this.index++,t[e].call(),this.index>this.capacity){for(let e=0,s=t.length-this.index;e<s;e++)t[e]=t[e+this.index];t.length-=this.index,this.index=0}}t.length=0,this.index=0,this.flushing=!1},this.registerPendingError=t=>{this.pendingErrors.push(t),this.requestErrorThrow()},this.requestFlush=n(this.flush),this.requestErrorThrow=s(()=>{if(this.pendingErrors.length)throw this.pendingErrors.shift()})}},h=new class{create(t){const e=this.freeTasks,s=e.length?e.pop():new i(this.onError,t=>e[e.length]=t);return s.task=t,s}constructor(t){this.onError=t,this.freeTasks=[]}}(r.registerPendingError);function o(t){r.enqueueTask(h.create(t))}export{o as a};
